# -*- coding: utf-8 -*-
"""Monitoramento_alagamentos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PLWjTuLL09GjTfmlT2t0o4QcmDer_pNQ

# Atividade 1 - Planejamento inteligente de drones para monitoramento de alagamentos

---

import dos dados das cidades com alagamentos
"""

import pandas as pd
!gdown 1K0tu3E-kcu7ikQcyNnKixjCY8vSjvxgl
df = pd.read_excel('alagamentos.xlsx')
df

"""---

visualização dos locais
"""

import folium
from tqdm.notebook import tqdm

# plotando no mapa
m = folium.Map([-14.5931291,-56.6985808], zoom_start=4)

df_sample = df.sample(1000)

for index,row in tqdm(df_sample.iterrows(),total=len(df_sample)):
  localidade = row['localidade'].split(',')
  lat = float(localidade[0])
  lng = float(localidade[1])
  text = row['descricao']
  folium.Marker([lat, lng], popup=text).add_to(m)

m

"""---

Definição da função de cálculo da distância entre dois pontos no plano, utilizando a fórmula de haversine.
"""

import math

def haversine(lat1, lon1, lat2, lon2):
    """
    Calcula a distância entre dois pontos na Terra (em km) usando a fórmula de Haversine.
    """
    R = 6371  # Raio da Terra em km
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    lat1 = math.radians(lat1)
    lat2 = math.radians(lat2)

    a = math.sin(dlat/2)**2 + math.cos(lat1)*math.cos(lat2)*math.sin(dlon/2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c

"""---

Função para ler o arquivo presente em df e coletar as coordenadas de cada um dos pontos afetados por alagamentos
"""

def get_coordenadas_cidades(df):
  coordenadas = set()

  for index,row in df.iterrows():
    localidade = row['localidade'].split(',')
    lat = float(localidade[0])
    lng = float(localidade[1])
    coordenadas.add((lat,lng))

  return coordenadas

coordenadas = list(get_coordenadas_cidades(df))
print(coordenadas)

"""---

A classe Node representa cada cidade afetada visitada pelo drone durante a missão de monitoramento. Para guiar a busca, utiliza-se uma heurística baseada na distância entre o nó pai e o nó atual, armazenada em node.h.
O custo acumulado real do trajeto até o nó atual é armazenado em node.custog, calculado como a soma das distâncias percorridas desde a origem. Além disso, é aplicada uma penalidade (node.penalidade) para refletir a viabilidade do deslocamento com base na autonomia restante do drone, considerando a necessidade de reabastecimento.
Cada Node também mantém referência ao seu nó pai (node.pai) e registra todas as cidades já visitadas (node.visitadas), permitindo reconstruir o caminho percorrido ao final da busca.
A função de busca f é calculada pela somatória das heurísticas (node.f = node.custog + node.penalidade)
"""

class Node:
  def __init__(self, lat, lng, visitadas = 0, autonomia = 750, pai = None):
    self.lat = lat
    self.lng = lng
    self.autonomia = autonomia
    self.pai = pai
    self.custog = 0
    self.penalidade = 0
    self.h = 0
    self.f = 0

    if pai:
      self.visitadas = pai.visitadas[:]
      self.visitadas.append((lat,lng))
    elif visitadas:
      self.visitadas = visitadas[:]
      self.visitadas.append((lat, lng))
    else:
      self.visitadas = [(lat, lng)]

  def __repr__(self):
      return (
            f"Node(lat={self.lat}, lng={self.lng}, f={self.f:.2f}, h={self.h:.2f}, "
            f"g={self.custog:.2f}, penalidade={self.penalidade:.2f}, "
            f"autonomia={self.autonomia:.2f}, visitadas={self.visitadas},)"
        )

"""---

Atribuições e visualização das coordenadas de cada capital do Brasil
"""

from IPython.display import display

""" as coordenadas das capitais foram pegar fora do exel passado por isso
algumas cidades capitais que tambem foram afetadas podem ser tratadas como
duas cidades diferentes para tratar isso coloquei uma restrição na distancia h,
em que considera distancias viaveis entre cidades acima de 5km.E para calculo de distancia
de uma capital foi coniderado 7km

"""

text = 'capital'
capitais_brasil = [
    (-10.9472, -37.0731),
    (-1.4558, -48.4902),
    (-19.9208, -43.9378),
    (2.8238, -60.6753),
    (-15.7797, -47.9297),
    (-20.4486, -54.6295),
    (-15.6010, -56.0974),
    (-25.4297, -49.2719),
    (-27.5954, -48.5480),
    (-3.7172, -38.5433),
    (-16.6864, -49.2643),
    (-7.1195, -34.8450),
    (0.0349, -51.0694),
    (-9.6658, -35.7350),
    (-3.1190, -60.0217),
    (-5.7945, -35.2110),
    (-10.1840, -48.3336),
    (-30.0346, -51.2177),
    (-8.7608, -63.8999),
    (-8.0476, -34.8770),
    (-9.9747, -67.8243),
    (-22.9068, -43.1729),
    (-12.9714, -38.5014),
    (-2.5307, -44.3068),
    (-23.5505, -46.6333),
    (-5.0892, -42.8016),
    (-20.3155, -40.3128),
]
mapa_capital = folium.Map([-14.5931293,-56.6985808], zoom_start=4);
for i,(lat,lng) in enumerate(capitais_brasil):

    folium.Marker([lat, lng], popup=text).add_to(mapa_capital)

#display(mapa_capital);


def distancia_capitais(node, capitais_brasil):
  distancia = []
  for i,(lat, lng) in enumerate(capitais_brasil):
    h = haversine(lat,lng,node.lat,node.lng)
    distancia.append((h ,lat, lng))
  return min(distancia)

juazeiro = Node(-7.23718, -39.3222)
disticanciatest = distancia_capitais(juazeiro, capitais_brasil)
print(disticanciatest)

"""Teste para ver a diferença entre as capitais do df(alagamentos.xlsx) e as capitais atribuidas a cima.Nota-se que há uma diferença de 7km entre as localizações por isso se um node estiver a menos de 7km de uma capital será contado como capital"""

rio = Node(-22.876652,-43.227875);
sp = Node(-23.567387,-46.570383)
t = distancia_capitais(rio, capitais_brasil);
t1 = distancia_capitais(sp, capitais_brasil);
print(t1)
print(t)

"""---

Função para direcionar o drone para a capital mais próxima a ele e reabastecer
"""

def ir_para_capital_e_reabastecer(node_atual, capitais_brasil):
    distancia_capital, lat_capital, lng_capital = distancia_capitais(node_atual, capitais_brasil)
    if distancia_capital < 7: ##esta em uma capital
        node_atual.autonomia = 750
        return node_atual
    if distancia_capital > node_atual.autonomia:
        raise Exception("Autonomia insuficiente")
        return None

    nova_visitadas = node_atual.visitadas.copy()
    nova_visitadas.append((lat_capital, lng_capital))
    nova_autonomia = 750

    node_capital = Node(lat_capital, lng_capital, nova_visitadas, nova_autonomia, node_atual)
    node_capital.h = 0
    node_capital.penalidade = 0
    node_capital.custog = node_atual.custog + distancia_capital
    node_capital.f = 0

    return node_capital

"""---

Função de cálculo da penalidade, a penalidade é obtida pela menor distância que node está das capitais, se a distância até uma capital for pequena a penalidade por escolher esse node será baixa, se o node não alcança nenhuma capital com sua autonomia sua penalidade será máxima, para que não seja escolhido.
"""

def calcula_penalidade(node_pai, capitais_brasil):
  penalidade = []

  for i,(lat, lng) in enumerate(capitais_brasil):
    h = haversine(lat,lng,node_pai.lat,node_pai.lng)
    if h < node_pai.autonomia:
      penalidade.append(h)



  if penalidade:
    penalidademin = min(penalidade)
    return penalidademin
  else:
    return None

"""---

Função para se expandir os filhos (espaço de busca) do node atual, a função expande somente para filhos viáveis, que seriam filhos em que o node pai pode chegar com sua autonomia, e filhos com penalidade menor que a máxima (filhos que com a autonomia restante chegariam a uma capital).Ao gerar os filhos possíveis também se calcula a função de busca e ordena os filhos em ordem de maior para menor.
"""

def expandir_nodes(node_pai):
  nodes_filhos = []

  for i,(lat, lng) in enumerate(coordenadas):
    if (lat, lng) not in node_pai.visitadas:
      h = haversine(lat,lng,node_pai.lat,node_pai.lng)
      if  0 < h < node_pai.autonomia: #garante somente filhos acessiveis
        nova_visitadas = node_pai.visitadas.copy()
        nova_visitadas.append((lat, lng))
        nova_autonomia = node_pai.autonomia - h
        node = Node(lat,lng,nova_visitadas,nova_autonomia,node_pai)
        penalidade = calcula_penalidade(node, capitais_brasil)
        if penalidade:  ##se tem penalidade consegue chegar a uma capital
          node.penalidade = penalidade
          node.h = h
          node.custog = node_pai.custog + h
          node.f = node.custog + node.penalidade
          nodes_filhos.append(node)
        else: # "apaga" o node
          node.lat = 0
          node.lng = 0
          node.penalidade = 0
          node.h = 0
          node.custog = 0
          node.f = 0
          node.pai = None
          node.visitadas = []

  nodes_filhos.sort(key=lambda node: node.f)
  return nodes_filhos

testenodes = expandir_nodes(Node(-23.567387,-46.570383))
print(testenodes)

"""---

Função da Busca A*, função para achar a rota que passe por mais pontos de alagamento antes de atingir o seu limite de autonomia, a busca começa por um node (nesse caso o node é (-23.567387,-46.570383) - São Paulo SP), esse node então é expandido usando a função expandir_nodes, assim são gerados os nodes filhos viáveis.Dentre os filhos viáveis o'que apresentar menor função de busca f, será escolhido como node atual, e novamente irá expandir seus filhos possíveis repetindo o processo até não haver mais filhos viáveis, sendo necessário ir a uma capital usando a função ir_para_capital_e_reabastecer, assim o último node é retornado pela busca A*.Há uma limpeza da fila_a, sendo contra a metrica do A* porem foi feito isso para se ter um espaço de busca viavel e finito.
"""

node_inicial = Node(-23.567387,-46.570383)
def busca_a(node_inicial):
  fila_a = []
  fila_a.append(node_inicial)
  cont = 0
  node_atual = fila_a.pop(0)
  while True:

    nodes_filhos = expandir_nodes(node_atual)
    #print(node_atual)
    #print(nodes_filhos)


    for filho in nodes_filhos:
      if (filho.lat, filho.lng) not in fila_a:
        fila_a.append(filho)

    if nodes_filhos:
      fila_a.sort(key=lambda node: node.f)
      node_atual = fila_a.pop(0)
      cont += 1

      if cont % 300 == 0:
        fila_a.clear(); # evitar que o espaço de busca seja muito grande

      #print(cont)
      print(node_atual)
      continue
    else:
      capital = ir_para_capital_e_reabastecer(node_atual, capitais_brasil)
      return capital


  return node_atual


ultimo_n0 = busca_a(node_inicial)
print(ultimo_n0)
print(ultimo_n0.visitadas)

print(node_inicial.visitadas)

"""---

Função para reconstruir o caminho até o último node através da lista de visitadas presente no último node.
"""

def Map_caminho(caminho):
  if not caminho:
    return None

  mapa = folium.Map(location=caminho[0], zoom_start=6)
  folium.Marker(caminho[0], tooltip="Origem", icon=folium.Icon(color='green')).add_to(mapa)
  folium.Marker(caminho[-1], tooltip="Destino", icon=folium.Icon(color='red')).add_to(mapa)
  folium.PolyLine(caminho, color="blue", weight=2.5, opacity=1).add_to(mapa)

  for lat, lng in caminho[1:-1]:
      folium.CircleMarker(location=(lat, lng), radius=3, color='blue', fill=True).add_to(mapa)

  return mapa

caminho = ultimo_n0.visitadas
Map_caminho(caminho)

"""---

Função para impedir o drone fique preso na área de uma capital sem filhos possiveis e finalizar o algorito se todas as capitais se encontrarem nesse estado.
"""

def trocar_capital(node):
  capitais_trocadas = []
  while len(capitais_trocadas) < len(capitais_brasil):
    distancia = []
    for i,(lat, lng) in enumerate(capitais_brasil):
      if (lat, lng) in capitais_trocadas:
        continue
      h = haversine(lat,lng,node.lat,node.lng)
      distancia.append((h ,lat, lng))


    distancia.sort(key=lambda h: h)
    distancia, lat, lng = distancia.pop(0)
    nova_cap = Node(lat,lng,node.visitadas.copy(),750,node)
    capital_com_filho = expandir_nodes(nova_cap)

    if capital_com_filho:
      print("nova capital disponivel")
      return nova_cap
    else:
      node = nova_cap
      capitais_trocadas.append((lat,lng))


  print("sem capitais disponiveis")
  return None

"""---

Função que utiliza a função busca_a para fazer o drone visitar todas as coordenadas possíveis, restabelecendo sua autonomia.
"""

def busca_a_completa(node_inicial):
  node_visitados = node_inicial.visitadas.copy()
  node_atual = node_inicial
  reabastecimento = 0

  while reabastecimento < 100:
    nodes_afetados_antes = [coord for coord in coordenadas if coord in node_atual.visitadas]
    node_resultado_busca_a = busca_a(node_atual)
    node_visitados = node_resultado_busca_a.visitadas.copy()
    nodes_afetados_visitados = [coord for coord in coordenadas if coord in node_visitados]

    if len(nodes_afetados_antes) == len(nodes_afetados_visitados):
      print("preso em uma ponta do pais")
      print(len(nodes_afetados_antes))
      print(len(nodes_afetados_visitados))
      nova_cap = trocar_capital(node_atual)
      if not nova_cap:
        print("len nodes afetados visitados",len(nodes_afetados_visitados))
        print("len nodes totais",len(coordenadas))
        return node_atual , len(nodes_afetados_visitados), len(coordenadas)
      node_atual = nova_cap
      reabastecimento += 1
      print("-----------------------------------abastecido----------------------------")
      continue

    if len(nodes_afetados_visitados) >= len(coordenadas):
      return node_resultado_busca_a

    reabastecimento += 1
    print("-----------------------------------abastecido----------------------------")
    print("len nodes visitados",len(node_visitados))
    print(node_resultado_busca_a.lat, node_resultado_busca_a.lng)
    node_atual = Node(
        node_resultado_busca_a.lat,
        node_resultado_busca_a.lng,
        node_visitados.copy(),
        750,
        None
        )
  return node_atual, len(nodes_afetados_visitados), len(coordenadas)
busca_completa, len_nodes_afetados, len_coordenadas  = busca_a_completa(node_inicial)
print(busca_completa)

"""---

Mapa da busca_a_completa
"""

map_completo = Map_caminho(busca_completa.visitadas)
map_completo

"""O drone não foi capaz de relatar todas as cidades afetadas, pois algumas estão muito longe de qualquer capital, sendo impossível checar a cidade com 750km de autonomia."""

print("cidades visitadas",len_nodes_afetados)
print("cidades totais",len_coordenadas)

uruguaiana = distancia_capitais(Node(-29.755,-57.087778),capitais_brasil)
print("distancia de uruguaiana capital mais proxima",uruguaiana)

juazeiro = distancia_capitais(Node(-7.23718, -39.3222), capitais_brasil)
print("distancia de juazeiro capital mais proxima",juazeiro)

rio_preto = distancia_capitais(Node(-20.8202, -49.3797),capitais_brasil)
print("distancia de rio preto capital mais proxima",rio_preto)